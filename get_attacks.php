<?php
// Enable gzip compression for faster transfer
if (!ob_start('ob_gzhandler')) ob_start();

header('Content-Type: application/json');
header('Cache-Control: public, max-age=60'); // Cache for 60 seconds in browser

// Use cached data generated by cron job (generate_attack_data.php)
$cacheFile = '/tmp/attack_data_cache.json';
$cacheMaxAge = 1800; // 30 minutes - if cache is older, regenerate

// Check if cache exists and is fresh
if (file_exists($cacheFile)) {
    $cacheAge = time() - filemtime($cacheFile);

    // Serve from cache if less than 10 minutes old
    if ($cacheAge < $cacheMaxAge) {
        echo file_get_contents($cacheFile);
        exit;
    }
}

// Cache is missing or stale - generate on-demand (fallback)
// This should rarely happen if cron is working properly

// Parse auth.log for failed login attempts (with 7-day filter)
function parseAuthLog($logFile, $daysBack = 7) {
    $attacks = [];
    $portStats = [];

    if (!file_exists($logFile)) {
        return ['attacks' => $attacks, 'portStats' => $portStats];
    }

    // Calculate cutoff timestamp (7 days ago)
    $cutoffTime = time() - ($daysBack * 86400);
    $currentYear = date('Y');

    // Read log file (handle compressed .gz files)
    if (substr($logFile, -3) === '.gz') {
        $lines = gzfile($logFile);
    } else {
        $lines = file($logFile);
    }

    if ($lines === false) {
        return ['attacks' => $attacks, 'portStats' => $portStats];
    }

    // Patterns to match failed login attempts
    // Note: We track the SERVICE being attacked, not the source port
    $patterns = [
        '/sshd.*Failed password for .+ from ([\d\.]+) port/' => 22,
        '/sshd.*Invalid user .+ from ([\d\.]+) port/' => 22,
        '/sshd.*Connection closed by authenticating user .+ ([\d\.]+) port/' => 22,
        '/sshd.*Disconnected from authenticating user .+ ([\d\.]+) port/' => 22,
        '/sshd.*Disconnected from invalid user .+ ([\d\.]+) port/' => 22,
        '/sshd.*Failed password for invalid user .+ from ([\d\.]+) port/' => 22,
        '/sshd.*Received disconnect from ([\d\.]+) port/' => 22,
        '/sshd.*Connection reset by ([\d\.]+) port/' => 22,
        '/sshd.*Bad protocol version identification .+ from ([\d\.]+) port/' => 22,
        // Add patterns for other services if found in logs
        '/ftpd.*from ([\d\.]+)/' => 21,
        '/telnetd.*from ([\d\.]+)/' => 23,
    ];

    foreach ($lines as $line) {
        foreach ($patterns as $pattern => $targetPort) {
            if (preg_match($pattern, $line, $matches)) {
                $ip = $matches[1];

                // Skip local/private IPs
                if (preg_match('/^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/', $ip)) {
                    break; // Break to next line
                }

                // Extract timestamp
                preg_match('/^(\w+\s+\d+\s+\d+:\d+:\d+)/', $line, $timeMatch);
                $timestamp = $timeMatch[1] ?? date('M d H:i:s');

                // Convert to Unix timestamp for filtering
                $timeWithYear = $timestamp . ' ' . $currentYear;
                $unixTime = strtotime($timeWithYear);

                // Handle year rollover - if parsed date is in the future, it's from last year
                if ($unixTime > time()) {
                    $unixTime = strtotime($timestamp . ' ' . ($currentYear - 1));
                }

                // Skip attacks older than 7 days
                if ($unixTime < $cutoffTime) {
                    break; // Skip to next line
                }

                if (!isset($attacks[$ip])) {
                    $attacks[$ip] = [
                        'ip' => $ip,
                        'count' => 0,
                        'firstSeen' => $timestamp,
                        'lastSeen' => $timestamp,
                        'attempts' => []
                    ];
                }

                $attacks[$ip]['count']++;
                $attacks[$ip]['lastSeen'] = $timestamp;
                $attacks[$ip]['attempts'][] = $timestamp;

                // Track service/port being attacked (destination port)
                if (!isset($portStats[$targetPort])) {
                    $portStats[$targetPort] = 0;
                }
                $portStats[$targetPort]++;

                // Break after first successful match for this line
                break;
            }
        }
    }

    return ['attacks' => $attacks, 'portStats' => $portStats];
}

// Parse Apache access.log for WordPress login attempts
function parseWordPressLog($logFile, $daysBack = 7) {
    $attacks = [];
    $portStats = [];

    if (!file_exists($logFile)) {
        return ['attacks' => $attacks, 'portStats' => $portStats];
    }

    $cutoffTime = time() - ($daysBack * 86400);

    $lines = file($logFile);
    if ($lines === false) {
        return ['attacks' => $attacks, 'portStats' => $portStats];
    }

    foreach ($lines as $line) {
        // Match POST requests to wp-login.php with failed attempts (200 status with large body = form returned)
        if (preg_match('/^(\S+) .* \[([^\]]+)\] "POST \/wp-login\.php HTTP\/\d\.\d" 200 [4-9]\d{3}/', $line, $matches)) {
            $ip = $matches[1];
            $timestamp = $matches[2];

            // Skip local/private IPs
            if (preg_match('/^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/', $ip)) {
                continue;
            }

            // Convert Apache timestamp to Unix time
            // Format: 12/Nov/2025:00:17:38 +0000
            // Convert to: 12-Nov-2025 00:17:38 +0000
            $timestampFormatted = preg_replace('/:/', ' ', $timestamp, 1); // Replace first : with space
            $timestampFormatted = str_replace('/', '-', $timestampFormatted); // Replace / with -
            $unixTime = strtotime($timestampFormatted);

            // Skip old attacks
            if ($unixTime < $cutoffTime) {
                continue;
            }

            // Convert to readable format
            $readableTime = date('M d H:i:s', $unixTime);

            if (!isset($attacks[$ip])) {
                $attacks[$ip] = [
                    'ip' => $ip,
                    'count' => 0,
                    'firstSeen' => $readableTime,
                    'lastSeen' => $readableTime,
                    'attempts' => [],
                    'service' => 'wordpress'  // Mark as WordPress attack
                ];
            }

            $attacks[$ip]['count']++;
            $attacks[$ip]['lastSeen'] = $readableTime;
            $attacks[$ip]['attempts'][] = $readableTime;

            // Track HTTP/HTTPS (port 80/443)
            if (!isset($portStats[80])) {
                $portStats[80] = 0;
            }
            $portStats[80]++;
        }
    }

    return ['attacks' => $attacks, 'portStats' => $portStats];
}

// Parse WordPress "Limit Login Attempts Reloaded" plugin data
function parseWordPressPluginData($daysBack = 7) {
    $attacks = [];
    $portStats = [];

    // Load WordPress to access options
    $wpLoad = dirname(__DIR__) . '/wp-load.php';
    if (!file_exists($wpLoad)) {
        return ['attacks' => $attacks, 'portStats' => $portStats];
    }

    // Load WordPress
    define('WP_USE_THEMES', false);
    require_once($wpLoad);

    // Get data from Limit Login Attempts Reloaded
    $logged = get_option('limit_login_logged', array());
    $lockouts = get_option('limit_login_lockouts', array());
    $blacklist = get_option('limit_login_blacklist', array());

    $cutoffTime = time() - ($daysBack * 86400);

    if (is_array($logged)) {
        foreach ($logged as $timestamp => $event) {
            // Skip old entries
            if ($timestamp < $cutoffTime) {
                continue;
            }

            $ip = $event['ip'];

            // Skip local/private IPs
            if (preg_match('/^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/', $ip)) {
                continue;
            }

            $readableTime = date('M d H:i:s', $timestamp);

            if (!isset($attacks[$ip])) {
                $attacks[$ip] = [
                    'ip' => $ip,
                    'count' => 0,
                    'firstSeen' => $readableTime,
                    'lastSeen' => $readableTime,
                    'attempts' => [],
                    'service' => 'wordpress',
                    'locked' => false,
                    'blacklisted' => false
                ];
            }

            $attacks[$ip]['count'] += $event['counter'];
            $attacks[$ip]['lastSeen'] = $readableTime;
            $attacks[$ip]['attempts'][] = $readableTime;

            // Check if currently locked
            if (isset($lockouts[$ip]) && $lockouts[$ip] > time()) {
                $attacks[$ip]['locked'] = true;
            }

            // Check if blacklisted
            if (is_array($blacklist) && in_array($ip, $blacklist)) {
                $attacks[$ip]['blacklisted'] = true;
            }

            // Track HTTP/HTTPS
            if (!isset($portStats[80])) {
                $portStats[80] = 0;
            }
            $portStats[80] += $event['counter'];
        }
    }

    return ['attacks' => $attacks, 'portStats' => $portStats];
}

// Get fail2ban banned IPs count
function getFail2banBannedCount() {
    $bannedCount = 0;

    // Try to get fail2ban status
    $output = [];
    $returnVar = 0;

    // Get all jails
    exec('sudo fail2ban-client status 2>/dev/null', $output, $returnVar);

    if ($returnVar === 0 && !empty($output)) {
        // Parse jail list
        foreach ($output as $line) {
            if (preg_match('/Jail list:\s*(.+)/', $line, $matches)) {
                $jails = array_map('trim', explode(',', $matches[1]));

                // Get banned IPs for each jail
                foreach ($jails as $jail) {
                    if (empty($jail)) continue;

                    $jailOutput = [];
                    exec("sudo fail2ban-client status {$jail} 2>/dev/null", $jailOutput);

                    foreach ($jailOutput as $jailLine) {
                        if (preg_match('/Currently banned:\s*(\d+)/', $jailLine, $countMatch)) {
                            $bannedCount += (int)$countMatch[1];
                        }
                    }
                }
                break;
            }
        }
    }

    return $bannedCount;
}

// Get geolocation for IP using free API
function getGeoLocation($ip) {
    static $apiCalls = 0; // Track API calls for rate limiting

    $cacheDir = '/tmp/geo_cache/';
    if (!is_dir($cacheDir)) {
        mkdir($cacheDir, 0755, true);
    }

    $cacheFile = $cacheDir . md5($ip) . '.json';

    // Check cache (24 hour cache for geo data)
    if (file_exists($cacheFile) && (time() - filemtime($cacheFile)) < 86400) {
        return json_decode(file_get_contents($cacheFile), true);
    }

    // Rate limit: ip-api.com allows 45 requests/minute
    // Sleep 1.5 seconds per API call to stay under limit (40/min)
    // Only sleep if we're making actual API calls (not cached)
    if ($apiCalls > 0) {
        usleep(1500000); // 1.5 seconds between requests
    }
    $apiCalls++;

    // Use ip-api.com (free, no key required, 45 req/min limit)
    $url = "http://ip-api.com/json/{$ip}?fields=status,country,countryCode,city,lat,lon,timezone";

    $context = stream_context_create([
        'http' => [
            'timeout' => 5,
            'ignore_errors' => true
        ]
    ]);

    $response = @file_get_contents($url, false, $context);

    if ($response === false) {
        return null;
    }

    $data = json_decode($response, true);

    if ($data && $data['status'] === 'success') {
        file_put_contents($cacheFile, json_encode($data));
        return $data;
    }

    return null;
}

// Main execution
try {
    // Read current and rotated logs, filter to last 7 days
    $sshLogFiles = [
        '/var/log/auth.log',
        '/var/log/auth.log.1',
        '/var/log/auth.log.2.gz',
        '/var/log/auth.log.3.gz',
        '/var/log/auth.log.4.gz'
        // Include up to 4 rotated logs to cover 7 days (assuming weekly rotation)
    ];

    $wordpressLogFiles = [
        '/var/log/apache2/access.log',
        '/var/log/apache2/access.log.1'
    ];

    $attacks = [];
    $portStats = [];

    // Parse SSH logs
    foreach ($sshLogFiles as $logFile) {
        if (file_exists($logFile)) {
            $logData = parseAuthLog($logFile, 7); // Last 7 days

            // Merge attacks (combine counts for same IP)
            foreach ($logData['attacks'] as $ip => $data) {
                if (!isset($attacks[$ip])) {
                    $attacks[$ip] = $data;
                    $attacks[$ip]['service'] = 'ssh';  // Mark as SSH
                } else {
                    // Merge attack data for same IP
                    $attacks[$ip]['count'] += $data['count'];
                    $attacks[$ip]['attempts'] = array_merge($attacks[$ip]['attempts'], $data['attempts']);
                    // Keep the most recent lastSeen
                    if (strtotime($data['lastSeen']) > strtotime($attacks[$ip]['lastSeen'])) {
                        $attacks[$ip]['lastSeen'] = $data['lastSeen'];
                    }
                    // Keep the earliest firstSeen
                    if (strtotime($data['firstSeen']) < strtotime($attacks[$ip]['firstSeen'])) {
                        $attacks[$ip]['firstSeen'] = $data['firstSeen'];
                    }
                }
            }

            // Merge port stats
            foreach ($logData['portStats'] as $port => $count) {
                if (!isset($portStats[$port])) {
                    $portStats[$port] = 0;
                }
                $portStats[$port] += $count;
            }
        }
    }

    // Parse WordPress logs
    foreach ($wordpressLogFiles as $logFile) {
        if (file_exists($logFile)) {
            $logData = parseWordPressLog($logFile, 7); // Last 7 days

            // Merge attacks (combine counts for same IP)
            foreach ($logData['attacks'] as $ip => $data) {
                if (!isset($attacks[$ip])) {
                    $attacks[$ip] = $data;
                } else {
                    // Merge attack data for same IP
                    $attacks[$ip]['count'] += $data['count'];
                    $attacks[$ip]['attempts'] = array_merge($attacks[$ip]['attempts'], $data['attempts']);
                    // Keep the most recent lastSeen
                    if (strtotime($data['lastSeen']) > strtotime($attacks[$ip]['lastSeen'])) {
                        $attacks[$ip]['lastSeen'] = $data['lastSeen'];
                    }
                    // Keep the earliest firstSeen
                    if (strtotime($data['firstSeen']) < strtotime($attacks[$ip]['firstSeen'])) {
                        $attacks[$ip]['firstSeen'] = $data['firstSeen'];
                    }
                }
            }

            // Merge port stats
            foreach ($logData['portStats'] as $port => $count) {
                if (!isset($portStats[$port])) {
                    $portStats[$port] = 0;
                }
                $portStats[$port] += $count;
            }
        }
    }

    // Parse WordPress plugin data (Limit Login Attempts Reloaded)
    $pluginData = parseWordPressPluginData(7);
    foreach ($pluginData['attacks'] as $ip => $data) {
        if (!isset($attacks[$ip])) {
            $attacks[$ip] = $data;
        } else {
            // Merge attack data for same IP
            $attacks[$ip]['count'] += $data['count'];
            $attacks[$ip]['attempts'] = array_merge($attacks[$ip]['attempts'], $data['attempts']);
            // Preserve locked/blacklisted status
            if (isset($data['locked']) && $data['locked']) {
                $attacks[$ip]['locked'] = true;
            }
            if (isset($data['blacklisted']) && $data['blacklisted']) {
                $attacks[$ip]['blacklisted'] = true;
            }
            // Keep the most recent lastSeen
            if (strtotime($data['lastSeen']) > strtotime($attacks[$ip]['lastSeen'])) {
                $attacks[$ip]['lastSeen'] = $data['lastSeen'];
            }
            // Keep the earliest firstSeen
            if (strtotime($data['firstSeen']) < strtotime($attacks[$ip]['firstSeen'])) {
                $attacks[$ip]['firstSeen'] = $data['firstSeen'];
            }
        }
    }

    // Merge port stats from plugin
    foreach ($pluginData['portStats'] as $port => $count) {
        if (!isset($portStats[$port])) {
            $portStats[$port] = 0;
        }
        $portStats[$port] += $count;
    }

    // Geolocate IPs (limit to top 100 by attempt count for 7-day view)
    $sortedAttacks = $attacks;
    uasort($sortedAttacks, function($a, $b) {
        return $b['count'] - $a['count'];
    });

    $geolocatedAttacks = [];
    $count = 0;

    foreach ($sortedAttacks as $ip => $data) {
        if ($count >= 100) break; // Limit to 100 for comprehensive 7-day view

        $geo = getGeoLocation($ip);

        if ($geo) {
            $geolocatedAttacks[] = [
                'ip' => $ip,
                'count' => $data['count'],
                'lat' => $geo['lat'] ?? null,
                'lon' => $geo['lon'] ?? null,
                'country' => $geo['country'] ?? 'Unknown',
                'countryCode' => $geo['countryCode'] ?? 'XX',
                'city' => $geo['city'] ?? 'Unknown',
                'lastSeen' => $data['lastSeen'],
                'firstSeen' => $data['firstSeen'],
                'service' => $data['service'] ?? 'ssh',  // Include service type
                'locked' => $data['locked'] ?? false,
                'blacklisted' => $data['blacklisted'] ?? false
            ];
        } else {
            // Add without geo data
            $geolocatedAttacks[] = [
                'ip' => $ip,
                'count' => $data['count'],
                'lat' => null,
                'lon' => null,
                'country' => 'Unknown',
                'countryCode' => 'XX',
                'city' => 'Unknown',
                'lastSeen' => $data['lastSeen'],
                'firstSeen' => $data['firstSeen'],
                'service' => $data['service'] ?? 'ssh',  // Include service type
                'locked' => $data['locked'] ?? false,
                'blacklisted' => $data['blacklisted'] ?? false
            ];
        }

        $count++;
    }

    // Calculate statistics
    $countryCounts = [];
    foreach ($geolocatedAttacks as $attack) {
        $country = $attack['countryCode'];
        if (!isset($countryCounts[$country])) {
            $countryCounts[$country] = 0;
        }
        $countryCounts[$country] += $attack['count'];
    }

    // Recent attacks for log - sort by most recent first
    $currentYear = date('Y');
    $recentAttacksList = [];

    foreach ($geolocatedAttacks as $attack) {
        // Parse timestamp with current year (format: "Oct 19 09:30:27")
        $timeWithYear = $attack['lastSeen'] . ' ' . $currentYear;
        $timestamp = strtotime($timeWithYear);

        // Handle year rollover - if parsed date is in the future, it's from last year
        if ($timestamp > time()) {
            $timestamp = strtotime($attack['lastSeen'] . ' ' . ($currentYear - 1));
        }

        $recentAttacksList[] = [
            'ip' => $attack['ip'],
            'time' => $attack['lastSeen'],
            'timestamp' => $timestamp, // Unix timestamp for sorting and client conversion
            'location' => $attack['city'] . ', ' . $attack['country'],
            'count' => $attack['count'],
            'service' => $attack['service'] ?? 'ssh',  // Include service type
            'locked' => $attack['locked'] ?? false,
            'blacklisted' => $attack['blacklisted'] ?? false
        ];
    }

    // Sort by timestamp (most recent first)
    usort($recentAttacksList, function($a, $b) {
        return $b['timestamp'] - $a['timestamp'];
    });

    // Keep timestamp field for client-side timezone conversion, take top 20
    $recentAttacks = array_slice($recentAttacksList, 0, 20);

    // Get fail2ban banned count
    $bannedIpCount = getFail2banBannedCount();

    // Add WordPress blacklist count
    $wpBlacklist = get_option('limit_login_blacklist', array());
    $wordpressBannedCount = is_array($wpBlacklist) ? count($wpBlacklist) : 0;
    $totalBannedIps = $bannedIpCount + $wordpressBannedCount;

    // Sort port statistics
    arsort($portStats);

    // Get common port names
    $portNames = [
        22 => 'SSH',
        23 => 'Telnet',
        25 => 'SMTP',
        80 => 'HTTP',
        110 => 'POP3',
        143 => 'IMAP',
        443 => 'HTTPS',
        3306 => 'MySQL',
        3389 => 'RDP',
        5432 => 'PostgreSQL',
        8080 => 'HTTP Alt',
        21 => 'FTP',
        53 => 'DNS',
        445 => 'SMB',
        1433 => 'MSSQL',
        27017 => 'MongoDB'
    ];

    $portData = [];
    foreach ($portStats as $port => $count) {
        $portData[] = [
            'port' => $port,
            'count' => $count,
            'service' => $portNames[$port] ?? 'Unknown'
        ];
    }

    $result = [
        'attacks' => $geolocatedAttacks,
        'totalAttempts' => array_sum(array_column($attacks, 'count')),
        'uniqueIps' => count($attacks),
        'countryCount' => count($countryCounts),
        'bannedIps' => $totalBannedIps,
        'countryCounts' => $countryCounts,
        'portStats' => $portData,
        'recentAttacks' => $recentAttacks,
        'lastUpdate' => date('Y-m-d H:i:s')
    ];

    // Save to cache for future requests
    file_put_contents($cacheFile, json_encode($result));
    chmod($cacheFile, 0644);

    echo json_encode($result);

} catch (Exception $e) {
    echo json_encode([
        'error' => $e->getMessage(),
        'attacks' => [],
        'totalAttempts' => 0,
        'uniqueIps' => 0,
        'countryCount' => 0,
        'bannedIps' => 0,
        'countryCounts' => [],
        'portStats' => [],
        'recentAttacks' => []
    ]);
}
